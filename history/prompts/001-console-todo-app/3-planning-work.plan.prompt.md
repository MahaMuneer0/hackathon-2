---
id: 3
title: planning-work
stage: plan
date: 2025-12-28
surface: agent
model: claude-sonnet-4-5-20250929
feature: console-todo-app
branch: 001-console-todo-app
user: ABC
command: sp.plan
labels: [plan, todo-app, architecture]
links:
  spec: specs/001-console-todo-app/spec.md
  ticket: null
  adr: null
  pr: null
files:
 - specs/001-console-todo-app/plan.md
 - specs/001-console-todo-app/research.md
 - specs/001-console-todo-app/data-model.md
 - specs/001-console-todo-app/quickstart.md
tests:
 - none
---

## Prompt

```text
# Technical Plan â€“ Phase I: In-Memory Python Console Todo App

## Goal
Build a simple, clean command-line Todo application in Python that runs in the console and stores all tasks only in memory (no files or database). The app must support all 5 Basic Level features:
1. Add Task
2. List / View Tasks
3. Update Task
4. Delete Task
5. Mark as Complete / Incomplete

## Guiding Principles (from Constitution)
- Pure Python only (no external libraries)
- Python 3.13+
- Type hints everywhere
- Clean, readable code (PEP 8)
- Small functions that do one thing
- Proper project structure with /src folder
- No manual coding â€“ everything generated by Claude Code from specs/tasks

## High-Level Architecture

The app will have three clear layers:

1. **Models Layer**
   - Define a `Task` dataclass to represent a single todo item.
   - Fields:
     - id: int (auto-incremented)
     - title: str (required)
     - description: str | None (optional)
     - completed: bool (default False)
     - created_at: datetime (auto-set when created)

2. **Manager / Service Layer**
   - A `TodoManager` class that holds the in-memory list and handles all operations.
   - Responsibilities:
     - Add new task â†’ generate next ID, set created_at, append to list
     - List all tasks (optionally filter by completed status later)
     - Get task by ID
     - Update task by ID (title and/or description)
     - Delete task by ID
     - Toggle completed status by ID
   - All methods return clear results or raise helpful exceptions (e.g., TaskNotFound)

3. **UI / Presentation Layer**
   - Simple console loop in main.py
   - Show a numbered menu
   - Use input() to get user choice and data
   - Use print() to show results (pretty formatting with tables or aligned text)
   - Handle invalid inputs gracefully (wrong ID, empty title, etc.)

## Project Structure
hackathon-todo/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ init.py
â”‚   â”œâ”€â”€ models.py          # Task dataclass
â”‚   â”œâ”€â”€ todo_manager.py    # TodoManager class with all operations
â”‚   â””â”€â”€ main.py            # Console menu loop and entry point
â”œâ”€â”€ constitution.md
â”œâ”€â”€ CLAUDE.md              # Instructions for Claude Code
â”œâ”€â”€ README.md              # Setup and run instructions
â””â”€â”€ .git/                  # Git repository

## Component Breakdown & Responsibilities

### 1. models.py
- Import `dataclass` from dataclasses and `datetime` from datetime
- Define `Task` dataclass with proper type hints and default values
- Add a simple `__str__` method for nice printing (ID, status emoji, title)

### 2. todo_manager.py
- Class `TodoManager`:
  - Private attribute `_tasks: list[Task] = []`
  - Private `_next_id: int = 1`
- Public methods:
  - `add_task(title: str, description: str | None = None) -> Task`
  - `get_all_tasks() -> list[Task]`
  - `get_task_by_id(task_id: int) -> Task` (raise ValueError if not found)
  - `update_task(task_id: int, title: str | None = None, description: str | None = None) -> Task`
  - `delete_task(task_id: int) -> None`
  - `toggle_complete(task_id: int) -> Task`

### 3. main.py
- Import `TodoManager` and `Task`
- Create global instance: `manager = TodoManager()`
- Infinite loop with menu:
  1. Add task
  2. List all tasks
  3. View task details
  4. Update task
  5. Delete task
  6. Toggle complete
  7. Quit
- Each option calls the correct manager method
- Pretty-print task list (show ID, âœ…/âŒ, title, created date)
- Clear error messages for invalid input

## Execution Flow Example
1. User runs `python -m src.main`
2. Menu displays
3. User chooses "1" â†’ prompted for title and optional description â†’ manager.add_task() â†’ success message + updated list
4. User chooses "2" â†’ manager.get_all_tasks() â†’ nicely formatted table printed

## Error Handling Strategy
- Validate title is not empty when adding/updating
- Catch ValueError for invalid task IDs and show friendly message
- Keep the menu running after errors (no crash)

## Future-Proofing (for later phases)
- Keep all logic inside TodoManager so it can be reused when we add database
- Use clear method names that match future API endpoints
- Avoid global state outside the manager instance

This plan is complete and ready to be broken into atomic tasks.
```

## Response snapshot

Created the implementation plan and supporting documentation for the Console Todo App. This included:
1. Implementation plan (plan.md) - detailed technical approach following the constitution
2. Research notes (research.md) - analysis of core components and technology decisions
3. Data model (data-model.md) - detailed Task entity definition and TodoManager structure
4. Quickstart guide (quickstart.md) - setup and usage instructions

All documents follow the constitution requirements for clean code with type hints, proper project structure, and adherence to the specified tech stack (pure Python).

## Outcome

- âœ… Impact: Created comprehensive planning artifacts for the console todo app implementation
- ğŸ§ª Tests: none
- ğŸ“ Files: Created plan.md, research.md, data-model.md, and quickstart.md
- ğŸ” Next prompts: Ready to proceed with task generation using /sp.tasks
- ğŸ§  Reflection: Planning phase complete with all required artifacts for implementation

## Evaluation notes (flywheel)

- Failure modes observed: none
- Graders run and results (PASS/FAIL): PASS
- Prompt variant (if applicable): N/A
- Next experiment (smallest change to try): Generate implementation tasks